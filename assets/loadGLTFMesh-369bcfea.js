import{nR as j,nS as L,nT as U,nU as v,aw as z,i1 as D,ay as G,cJ as _,nV as q,nW as N,b4 as B,nX as V,nY as k,nZ as J,n_ as K,dk as Q,dx as S,n$ as W,lP as C,o0 as X,o1 as Y,n1 as Z,o2 as H,o3 as ee,o4 as h,o5 as te,o6 as ne,nc as O,o7 as M,nd as F,o8 as re,ne as oe,ng as R,nf as I,o9 as E,oa as se,nh as ae,it as w,cr as le,cP as ue,ob as ce,ni as ie,oc as fe,hq as pe,od as de}from"./index-755e30b3.js";import{M as me}from"./vertexSpaceConversion-c83dffb3.js";function xe(e,t,n){const u=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,l=n?n.count:t.count;let s=(n?.dstIndex??0)*o,p=(n?.srcIndex??0)*i;for(let c=0;c<l;++c){for(let r=0;r<9;++r)u[s+r]=a[p+r];s+=o,p+=i}}Object.freeze(Object.defineProperty({__proto__:null,copy:xe},Symbol.toStringTag,{value:"Module"}));function ge(e,t,n){const u=e.typedBuffer,o=e.typedBufferStride,a=t.typedBuffer,i=t.typedBufferStride,l=n?n.count:t.count;let s=(n?.dstIndex??0)*o,p=(n?.srcIndex??0)*i;for(let c=0;c<l;++c){for(let r=0;r<16;++r)u[s+r]=a[p+r];s+=o,p+=i}}Object.freeze(Object.defineProperty({__proto__:null,copy:ge},Symbol.toStringTag,{value:"Module"}));function T(e,t){return new e(new ArrayBuffer(t*e.ElementCount*j(e.ElementType)))}async function Ae(e,t,n){const u=new L(Te(n)),o=(await U(u,t,n,!0)).model,a=o.lods.shift(),i=new Map,l=new Map;o.textures.forEach((g,y)=>i.set(y,he(g))),o.materials.forEach((g,y)=>l.set(y,we(g,i)));const s=ye(a);for(const g of s.parts)be(s,g,l);const{position:p,normal:c,tangent:r,color:f,texCoord0:d}=s.vertexAttributes,x=v(e,n),P=e.spatialReference.isGeographic?v(e):x,b=me({vertexAttributes:{position:p.typedBuffer,normal:c?.typedBuffer,tangent:r?.typedBuffer},vertexSpace:P,spatialReference:e.spatialReference},x,{allowBufferReuse:!0,sourceUnit:"meters"});if(!b)throw new z("loadGLTFMesh()","Failed to load mesh from glTF due to projection errors");return{transform:null,vertexSpace:x,components:s.components,spatialReference:e.spatialReference,vertexAttributes:new D({...b,color:f?.typedBuffer,uv:d?.typedBuffer})}}function Te(e){const t=e?.resolveFile;return t?{busy:!1,request:async(n,u,o)=>{const a=t?.(n)??n;return(await G(a,{responseType:u==="image"?"image":u==="binary"||u==="image+type"?"array-buffer":"json",signal:o?.signal,timeout:0})).data}}:null}function $(e,t){if(e==null)return"-";const n=e.typedBuffer;return`${_(t,n.buffer,()=>t.size)}/${n.byteOffset}/${n.byteLength}`}function $e(e){return e!=null?e.toString():"-"}function ye(e){let t=0;const n={color:!1,tangent:!1,normal:!1,texCoord0:!1},u=new Map,o=new Map,a=[];for(const i of e.parts){const{attributes:{position:l,normal:s,color:p,tangent:c,texCoord0:r}}=i,f=`
      ${$(l,u)}/
      ${$(s,u)}/
      ${$(p,u)}/
      ${$(c,u)}/
      ${$(r,u)}/
      ${$e(i.transform)}
    `;let d=!1;const x=_(o,f,()=>(d=!0,{start:t,length:l.count}));d&&(t+=l.count),s&&(n.normal=!0),p&&(n.color=!0),c&&(n.tangent=!0),r&&(n.texCoord0=!0),a.push({gltf:i,writeVertices:d,region:x})}return{vertexAttributes:{position:T(ce,t),normal:n.normal?T(I,t):null,tangent:n.tangent?T(O,t):null,color:n.color?T(F,t):null,texCoord0:n.texCoord0?T(ie,t):null},parts:a,components:[]}}function he(e){return new q({data:(N(e.data),e.data),wrap:Se(e.parameters.wrap)})}function we(e,t){const n=new B(Ce(e.color,e.opacity)),u=e.emissiveFactor?new B(Me(e.emissiveFactor)):null,o=a=>a?new fe({scale:a.scale?[a.scale[0],a.scale[1]]:[1,1],rotation:pe(a.rotation??0),offset:a.offset?[a.offset[0],a.offset[1]]:[0,0]}):null;return new V({color:n,colorTexture:t.get(e.textureColor),normalTexture:t.get(e.textureNormal),emissiveColor:u,emissiveTexture:t.get(e.textureEmissive),occlusionTexture:t.get(e.textureOcclusion),alphaMode:Be(e.alphaMode),alphaCutoff:e.alphaCutoff,doubleSided:e.doubleSided,metallic:e.metallicFactor,roughness:e.roughnessFactor,metallicRoughnessTexture:t.get(e.textureMetallicRoughness),colorTextureTransform:o(e.colorTextureTransform),normalTextureTransform:o(e.normalTextureTransform),occlusionTextureTransform:o(e.occlusionTextureTransform),emissiveTextureTransform:o(e.emissiveTextureTransform),metallicRoughnessTextureTransform:o(e.metallicRoughnessTextureTransform)})}function be(e,t,n){t.writeVertices&&ve(e,t);const{indices:u,attributes:o,primitiveType:a,material:i}=t.gltf;let l=k(u||o.position.count,a);const s=t.region.start;if(s){const p=new Uint32Array(l);for(let c=0;c<l.length;c++)p[c]+=s;l=p}e.components.push(new J({name:t.gltf.name,faces:l,material:n.get(i),shading:o.normal?"source":"flat",trustSourceNormals:!0}))}function ve(e,t){const{position:n,normal:u,tangent:o,color:a,texCoord0:i}=e.vertexAttributes,l=t.region.start,{attributes:s,transform:p}=t.gltf,c=s.position.count;if(K(n.slice(l,c),s.position,p),s.normal!=null&&u!=null){const r=Q(S(),p),f=u.slice(l,c);W(f,s.normal,r),C(r)&&X(f,f)}else u!=null&&Y(u,0,0,1,{dstIndex:l,count:c});if(s.tangent!=null&&o!=null){const r=Z(S(),p),f=o.slice(l,c);H(f,s.tangent,r),C(r)&&ee(f,f)}else o!=null&&h(o,0,0,1,1,{dstIndex:l,count:c});if(s.texCoord0!=null&&i!=null?te(i.slice(l,c),s.texCoord0):i!=null&&ne(i,0,0,{dstIndex:l,count:c}),s.color!=null&&a!=null){const r=s.color,f=a.slice(l,c);if(r.elementCount===4)r instanceof O?M(f,r,255):r instanceof F?re(f,r):r instanceof oe&&M(f,r,1/256);else{h(f,255,255,255,255);const d=R.fromTypedArray(f.typedBuffer,f.typedBufferStride);r instanceof I?E(d,r,255):r instanceof R?se(d,r):r instanceof ae&&E(d,r,1/256)}}else a!=null&&h(a.slice(l,c),255,255,255,255)}function Be(e){switch(e){case"OPAQUE":return"opaque";case"MASK":return"mask";case"BLEND":return"blend"}}function Se(e){return{horizontal:A(e.s),vertical:A(e.t)}}function A(e){switch(e){case w.CLAMP_TO_EDGE:return"clamp";case w.MIRRORED_REPEAT:return"mirror";case w.REPEAT:return"repeat"}}function m(e){return e**(1/de)*255}function Ce(e,t){return le(m(e[0]),m(e[1]),m(e[2]),t)}function Me(e){return ue(m(e[0]),m(e[1]),m(e[2]))}export{Ae as loadGLTFMesh};
