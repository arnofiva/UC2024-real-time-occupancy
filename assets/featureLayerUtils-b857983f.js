import{du as P,dv as Y,dw as _,dx as m,cT as z,dy as $,dz as b,dA as u,dB as v,dC as B,av as d,dD as I}from"./index-c0f955a7.js";import{I as G,y as E,w as N,b as j,u as k,v as C,l as x,d as V,m as T}from"./utils-a4281b92.js";import{r as q}from"./fetchService-af1bc981.js";import{o as L}from"./jsonContext-ecb82249.js";import"./requestPresets-5652178e.js";const f="Feature Service",h="feature-layer-utils",H=`${h}-save`,Q=`${h}-save-as`,p=`${h}-saveall`,y=`${h}-saveall-as`;function w(a){return{isValid:B(a)&&(a.type!=="feature"||!a.dynamicDataSource),errorMessage:"Feature layer should be a layer or table in a map or feature service"}}function g(a){const e=[],t=[];for(const{layer:s,layerJSON:n}of a)s.isTable?t.push(n):e.push(n);return{layers:e,tables:t}}function O(a){return g([a])}async function J(a,e){return/\/\d+\/?$/.test(a.url)?O(e[0]):D(e,a)}async function D(a,e){if(!e)return a.reverse(),g(a);const{layer:{url:t,customParameters:s,apiKey:n}}=a[0];let r=await e.fetchData("json");r?.layers!=null&&r?.tables!=null||(r=await Z(r,{url:t??"",customParameters:s,apiKey:n},a.map(l=>l.layer.layerId)));for(const l of a)M(l.layer,l.layerJSON,r);return r}async function Z(a,e,t){a||(a={}),a.layers||(a.layers=[]),a.tables||(a.tables=[]);const{url:s,customParameters:n,apiKey:r}=e,{serviceJSON:l,layersJSON:o}=await q(s,{customParameters:n,apiKey:r}),i=S(a.layers,l.layers,t),c=S(a.tables,l.tables,t);a.layers=i.itemResources,a.tables=c.itemResources;const F=[...i.added,...c.added],K=o?[...o.layers,...o.tables]:[];return await W(a,F,s,K),a}function S(a,e,t){const s=Y(a,e,(r,l)=>r.id===l.id);a=a.filter(r=>!s.removed.some(l=>l.id===r.id));const n=s.added.map(({id:r})=>({id:r}));return n.forEach(({id:r})=>{a.push({id:r})}),{itemResources:a,added:n.filter(({id:r})=>!t.includes(r))}}async function W(a,e,t,s){const n=e.map(({id:r})=>new _({url:t,layerId:r,sourceJSON:s.find(({id:l})=>l===r)}));await Promise.allSettled(n.map(r=>r.load())),n.forEach(r=>{const{layerId:l,loaded:o,defaultPopupTemplate:i}=r;!o||i==null||M(r,{id:l,popupInfo:i.toJSON()},a)})}function M(a,e,t){a.isTable?A(t.tables,e):A(t.layers,e)}function A(a,e){const t=a.findIndex(({id:s})=>s===e.id);t===-1?a.push(e):a[t]=e}function R(a,e){if(!a.length)throw new d(`${e}:missing-parameters`,"'layers' array should contain at least one feature layer")}function X(a,e){const t=a.map(s=>s.portalItem.id);if(new Set(t).size>1)throw new d(`${e}:invalid-parameters`,"All layers in the 'layers' array should be loaded from the same portal item")}function U(a,e){const t=a.map(s=>s.layerId);if(new Set(t).size!==t.length)throw new d(`${e}:invalid-parameters`,"'layers' array should contain only one instance each of layer or table in a feature service")}async function aa(a){R(a,p),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,p,w),V({layer:e,itemType:f,errorNamePrefix:p});X(a,p),U(a,p)}async function ea(a,e){const{url:t,layerId:s,title:n,fullExtent:r,isTable:l}=a,o=m(t);e.url=o?.serverType==="FeatureServer"?t:`${t}/${s}`,e.title||(e.title=n),e.extent=null,l||r==null||(e.extent=await $(r)),b(e,u.METADATA),b(e,u.MULTI_LAYER),I(e,u.SINGLE_LAYER),l&&I(e,u.TABLE)}function ta(a,e){for(const r of a){const l=r.parsedUrl.path,o=m(l);if(!o?.url.path)throw new d(`${e}:invalid-parameters`,T(r,`has unsupported url pattern: ${l}`),{layer:r});const c=o?.serverType;if(c!=="FeatureServer"&&c!=="MapServer")throw new d(`${e}:invalid-parameters`,T(r,`has unsupported server type: ${c}`),{layer:r});if(c==="MapServer"&&a.length>1)throw new d(`${e}:invalid-parameters`,"Only one layer or table in a map service can be saved")}const t=m(a[0].parsedUrl.path),s=t?.url.path;if(!a.every(r=>m(r.parsedUrl.path)?.url.path===s))throw new d(`${e}:invalid-parameters`,"'layers' array should only contain layers or tables that belong to the same feature service")}async function ra(a){R(a,y),await Promise.all(a.map(e=>e.load()));for(const e of a)x(e,y,w);ta(a,y),U(a,y)}async function sa(a,e){let t=0,s=0;for(const{isTable:l}of e)l?s++:t++;const n=e[0].parsedUrl.path,r=m(n);if(a.url=r?.serverType==="FeatureServer"?r.url.path:n,a.title||(a.title=r.title),a.extent=null,t>0){const l=e.map(o=>o.fullExtent).filter(z).reduce((o,i)=>o.clone().union(i));l&&(a.extent=await $(l))}b(a,u.METADATA),v(a,u.MULTI_LAYER,e.length>1),v(a,u.SINGLE_LAYER,e.length===1),v(a,u.TABLE,s>0&&t===0),N(a)}async function ca(a,e){return G({layer:a,itemType:f,validateLayer:w,createItemData:(t,s)=>J(s,[t]),errorNamePrefix:H},e)}async function da(a,e){await aa(a);const t=a[0].portalItem,s=L(t),n=await Promise.all(a.map(l=>E(l,s,e))),r=await J(t,a.map((l,o)=>({layer:l,layerJSON:n[o]})));return N(t),await t.update({data:r}),await Promise.all(a.slice(1).map(l=>l.portalItem.reload())),P(s),t.clone()}async function pa(a,e,t){return j({layer:a,itemType:f,validateLayer:w,createItemData:(s,n)=>Promise.resolve(O(s)),errorNamePrefix:Q,newItem:e,setItemProperties:ea},t)}async function ya(a,e,t){await ra(a);const s=k({itemType:f,errorNamePrefix:y,newItem:e}),n=L(s),r=await Promise.all(a.map(o=>E(o,n,t))),l=await D(a.map((o,i)=>({layer:o,layerJSON:r[i]})));await sa(s,a),await C(s,l,t);for(const o of a)o.portalItem=s.clone();return P(n),s}export{ca as save,da as saveAll,ya as saveAllAs,pa as saveAs};
