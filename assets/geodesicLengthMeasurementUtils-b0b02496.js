import{nA as v,dP as V,bx as ft,fR as X,nB as pt,aw as P,bI as st,bu as dt,al as Mt,nC as mt,nD as gt,fp as $t,cM as O,eI as yt,dZ as wt,l$ as Rt,eH as vt,nE as zt,m0 as at,dJ as bt,nF as U}from"./index-ab96db07.js";import{geodesicLength as rt}from"./geometryEngine-ebfb00c5.js";function it(t){if(!t)return null;if(X(t)&&t.wkid){const n=pt[t.wkid];if(n)return n}const e=t.wkt2||t.wkt;if(e){const n=jt(e);if(n)return n}return null}function jt(t){const e=mt.exec(t);if(!e||e.length!==2)return null;const n=e[1].split(",");if(!n||n.length<3)return null;const s=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(s)||isNaN(a)?null:{a:s,f:a===0?0:1/a}}function B(t){const e=it(t);if(qt(e))return e;const n=e.a*(1-e.f);return Object.assign(e,{b:n,eSq:1-(n/e.a)**2,radius:(2*e.a+n)/3,densificationRatio:1e4/((2*e.a+n)/3)})}function qt(t){return t!=null&&"b"in t&&"eSq"in t&&"radius"in t}function E(t,e,n){const{a:s,eSq:a}=B(n),r=Math.sqrt(a),c=Math.sin(e[1]*v),i=s*e[0]*v;let l;return a>0?l=s*((1-a)*(c/(1-a*(c*c))-1/(2*r)*Math.log((1-r*c)/(1+r*c))))*.5:l=s*c,t[0]=i,t[1]=l,t}function F(t){return it(t)!==null}function Zt(t,e="square-meters"){if(t.some(c=>!F(c.spatialReference)))throw new P("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let c=0;c<t.length;c++){const i=t[c],l=i.spatialReference,{radius:u,densificationRatio:h}=B(l),o=u*h;n.push(xt(i,o))}const s=[],a=[0,0],r=[0,0];for(let c=0;c<n.length;c++){const{rings:i,spatialReference:l}=n[c];let u=0;for(let h=0;h<i.length;h++){const o=i[h];E(a,o[0],l),E(r,o[o.length-1],l);let d=r[0]*a[1]-a[0]*r[1];for(let M=0;M<o.length-1;M++)E(a,o[M+1],l),E(r,o[M],l),d+=r[0]*a[1]-a[0]*r[1];u+=d}u=st(u,"square-meters",e),s.push(u/-2)}return s}function St(t,e="meters"){if(!t)throw new P("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(t.some(s=>!F(s.spatialReference)))throw new P("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let s=0;s<t.length;s++){const a=t[s],{spatialReference:r}=a,c=a.type==="polyline"?a.paths:a.rings;let i=0;for(let l=0;l<c.length;l++){const u=c[l];let h=0;for(let o=1;o<u.length;o++){const d=u[o-1][0],M=u[o][0],y=u[o-1][1],m=u[o][1];if(y!==m||d!==M){const p=new Y;_(p,[d,y],[M,m],r),h+=p.distance}}i+=h}i=st(i,"meters",e),n.push(i)}return n}function xt(t,e){if(t.type!=="polyline"&&t.type!=="polygon")throw new P("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=t;if(!F(n))throw new P("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s=t.type==="polyline"?t.paths:t.rings,a=[],r=[0,0],c=new Y;for(const i of s){const l=[];a.push(l),l.push([i[0][0],i[0][1]]);let u,h,o=i[0][0],d=i[0][1];for(let M=0;M<i.length-1;M++){if(u=i[M+1][0],h=i[M+1][1],o===u&&d===h)continue;const y=[o,d];_(c,[o,d],[u,h],n);const{azimuth:m,distance:p}=c,w=p/e;if(w>1){for(let g=1;g<=w-1;g++)W(r,y,m,g*e,n),l.push(r.slice(0));W(r,y,m,(p+Math.floor(w-1)*e)/2,n),l.push(r.slice(0))}W(r,y,m,p,n),l.push(r.slice(0)),o=r[0],d=r[1]}}return t.type==="polyline"?new dt({paths:a,spatialReference:n}):new Mt({rings:a,spatialReference:n})}class Y{constructor(e=0,n=void 0,s=void 0){this.distance=e,this.azimuth=n,this.reverseAzimuth=s}}function W(t,e,n,s,a){const r=e[0],c=e[1],i=r*v,l=c*v,u=(n??0)*v,{a:h,b:o,f:d}=B(a),M=Math.sin(u),y=Math.cos(u),m=(1-d)*Math.tan(l),p=1/Math.sqrt(1+m*m),w=m*p,g=Math.atan2(m,y),C=p*M,x=C*C,z=1-x,f=z*(h*h-o*o)/(o*o),A=1+f/16384*(4096+f*(f*(320-175*f)-768)),N=f/1024*(256+f*(f*(74-47*f)-128));let R,j,$,k,S=s/(o*A),b=2*Math.PI;for(;Math.abs(S-b)>1e-12;)$=Math.cos(2*g+S),R=Math.sin(S),j=Math.cos(S),k=N*R*($+N/4*(j*(2*$*$-1)-N/6*$*(4*R*R-3)*(4*$*$-3))),b=S,S=s/(o*A)+k;const q=w*R-p*j*y,I=Math.atan2(w*j+p*R*y,(1-d)*Math.sqrt(x+q*q)),D=Math.atan2(R*M,p*j-w*R*y),G=d/16*z*(4+d*(4-3*z)),J=I/v,L=(i+(D-(1-G)*d*C*(S+G*R*($+G*j*(2*$*$-1)))))/v;return t[0]=L,t[1]=J,t}function _(t,e,n,s){const a=e[0]*v,r=e[1]*v,c=n[0]*v,i=n[1]*v,{a:l,b:u,f:h,radius:o}=B(s),d=c-a,M=Math.atan((1-h)*Math.tan(r)),y=Math.atan((1-h)*Math.tan(i)),m=Math.sin(M),p=Math.cos(M),w=Math.sin(y),g=Math.cos(y);let C,x,z,f,A,N,R,j,$,k,S=1e3,b=d;do{if(R=Math.sin(b),j=Math.cos(b),z=Math.sqrt(g*R*(g*R)+(p*w-m*g*j)*(p*w-m*g*j)),z===0)return t.distance=0,t.azimuth=void 0,t.reverseAzimuth=void 0,t;A=m*w+p*g*j,N=Math.atan2(z,A),$=p*g*R/z,x=1-$*$,f=A-2*m*w/x,isNaN(f)&&(f=0),k=h/16*x*(4+h*(4-3*x)),C=b,b=d+(1-k)*h*$*(N+k*z*(f+k*A*(2*f*f-1)))}while(Math.abs(b-C)>1e-12&&--S>0);if(S===0){const L=o,ct=Math.acos(Math.sin(r)*Math.sin(i)+Math.cos(r)*Math.cos(i)*Math.cos(c-a))*L,tt=c-a,lt=Math.sin(tt)*Math.cos(i),ut=Math.cos(r)*Math.sin(i)-Math.sin(r)*Math.cos(i)*Math.cos(tt),ht=Math.atan2(lt,ut);return t.azimuth=ht/v,t.distance=ct,t.reverseAzimuth=void 0,t}const q=x*(l*l-u*u)/(u*u),I=q/1024*(256+q*(q*(74-47*q)-128)),D=u*(1+q/16384*(4096+q*(q*(320-175*q)-768)))*(N-I*z*(f+I/4*(A*(2*f*f-1)-I/6*f*(4*z*z-3)*(4*f*f-3)))),G=Math.atan2(g*Math.sin(b),p*w-m*g*Math.cos(b)),J=Math.atan2(p*Math.sin(b),p*w*Math.cos(b)-m*g);return t.azimuth=G/v,t.distance=D,t.reverseAzimuth=J/v,t}function Ht(t){return F(t)?t:V(t)?ft.WGS84:null}function Ot(t,e,n,s){n.projectToRenderScreen(t,et),n.projectToRenderScreen(e,nt),wt(s,nt,et),Rt(s,s)}function At(t,e,n,s,a=O()){const r=vt(Q,t);return r[2]=zt(s,r,e,n)||0,s.renderCoordsHelper.toRenderCoords(r,e,a),a}function Ut(t,e,n,s){return s.type==="2d"?(T.x=t[0],T.y=t[1],T.spatialReference=e,s.toScreen(T)):(At(t,e,n,s,Q),s.state.camera.projectToScreen(Q,K),gt(K[0],K[1]))}const T=$t(0,0,0,null),Q=O(),et=at(),nt=at(),K=yt();function Bt(t){return X(t)&&F(t)||V(t)}function ot(t,e,n,...s){return X(t)&&F(t)?e.apply(void 0,s):V(t)?n.apply(void 0,s):null}const Dt=1e5;function Jt(t){const{spatialReference:e}=t;return ot(e,Ft,It,t)}function Lt(t,e){if(!bt(t.spatialReference,e.spatialReference))return null;const{spatialReference:n}=t;return Z[0]=t.x,Z[1]=t.y,Z[2]=t.hasZ?t.z:0,H[0]=e.x,H[1]=e.y,H[2]=e.hasZ?e.z:0,Nt(Z,H,n)}function Nt(t,e,n){return ot(n,kt,Ct,t,e,n)}function kt(t,e,n){return U(_(Pt,t,e,n).distance,"meters")}function Ct(t,e,n){return U(rt(Gt(t,e,n),"meters"),"meters")}function Ft(t){return U(St([t],"meters")[0],"meters")}function It(t){return U(rt(t,"meters"),"meters")}function Gt(t,e,n){return{type:"polyline",spatialReference:n,paths:[[[...t],[...e]]]}}const Pt=new Y,Z=O(),H=O();export{Ht as A,Ot as a,W as b,Ut as d,Lt as f,Dt as i,_ as j,At as l,Jt as m,ot as p,Bt as r,Nt as u,Zt as y,Y as z};
